<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="robots" content="noindex, nofollow">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Camus: The Absurd Journey</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=EB+Garamond:ital,wght@0,400;0,600;1,400&display=swap');
    
    html, body, #root { 
      height: 100%; 
      margin: 0; 
      overflow: hidden;
    }
    
    .cinzel { font-family: 'Cinzel', serif; }
    .garamond { font-family: 'EB Garamond', serif; }
    
    @keyframes flicker {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.8; }
    }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-10px) rotate(-1deg); }
      75% { transform: translateX(10px) rotate(1deg); }
    }
    
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .fade-in-up {
      animation: fadeInUp 1s ease-out;
    }
    
    .vignette {
      box-shadow: inset 0 0 100px rgba(0,0,0,0.8);
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
  const { useState, useEffect, useRef } = React;

  const CamusGame = () => {
    const [gameState, setGameState] = useState('intro');
    const [dialogStep, setDialogStep] = useState(0);
    const [speedLevel, setSpeedLevel] = useState(0);
    const speedLevelRef = useRef(0);
    const [drivingDialogIndex, setDrivingDialogIndex] = useState(0);
    const [showGasButton, setShowGasButton] = useState(false);
    const [displayedText, setDisplayedText] = useState('');
    const [isTyping, setIsTyping] = useState(false);
    const [currentFullText, setCurrentFullText] = useState('');
    const typingIntervalRef = useRef(null);
    const [showCrashEffect, setShowCrashEffect] = useState(false);
    const [crashAnimationTime, setCrashAnimationTime] = useState(0);
    const mountRef = useRef(null);
    const crashMountRef = useRef(null);
    const sceneRef = useRef(null);
    const animationRef = useRef(null);
    const crashAnimationRef = useRef(null);
    const audioContextRef = useRef(null);

    const dialogLines = [
      { speaker: 'Michel Gallimard', text: 'Albert, ich fahre nach Paris zurück. Möchtest du in meinem Facel Vega mitfahren?', otherSpeaker: 'Albert Camus' },
      { speaker: 'Albert Camus', text: 'Ich weiß nicht, Michel. Ich habe bereits eine Zugkarte.', otherSpeaker: 'Albert Camus' },
      { speaker: 'Michel Gallimard', text: 'Janine und Anne werden auch dabei sein. Es wird eine angenehme Fahrt.', otherSpeaker: 'Janine Gallimard' },
      { speaker: 'Janine Gallimard', text: 'Es wäre doch schön, gemeinsam zu fahren, Albert.', otherSpeaker: 'Janine Gallimard' },
      { speaker: 'Michel Gallimard', text: 'Anne freut sich schon auf die Reise.', otherSpeaker: 'Anne Gallimard' },
      { speaker: 'Anne Gallimard', text: 'Wir haben genug Platz im Auto, Monsieur Camus.', otherSpeaker: 'Anne Gallimard' },
      { speaker: 'Anne Gallimard', text: 'Mami, wieso sieht der Reifen so komisch aus?', otherSpeaker: 'Anne Gallimard' },
      { speaker: 'Janine Gallimard', text: 'Sei still und steig ein.', otherSpeaker: 'Janine Gallimard' },
      { speaker: 'Michel Gallimard', text: 'Komm schon, Albert! Der Wagen fährt wunderbar. Du wirst es nicht bereuen.', otherSpeaker: 'Albert Camus' },
      { speaker: 'Albert Camus', text: 'Nun gut... Ihr habt mich überzeugt. Ich komme mit.', otherSpeaker: 'Albert Camus' }
    ];

    const drivingDialogs = [
      { speaker: 'Michel Gallimard', text: 'Es ist ein schöner Tag für eine Fahrt nach Paris.', showGas: false },
      { speaker: 'Albert Camus', text: 'Ja, die Landschaft ist wirklich beeindruckend.', showGas: false },
      { speaker: 'Michel Gallimard', text: 'Wir machen ausgezeichnete Zeit.', showGas: false },
      { speaker: 'Albert Camus', text: 'Der Wagen fährt sehr komfortabel.', showGas: true },
      { speaker: 'Michel Gallimard', text: 'Der Facel Vega ist ein Meisterwerk französischer Ingenieurskunst.', showGas: false },
      { speaker: 'Albert Camus', text: 'Die Straße wird schmaler hier...', showGas: false },
      { speaker: 'Michel Gallimard', text: 'Keine Sorge, ich kenne diese Strecke gut.', showGas: false },
      { speaker: 'Albert Camus', text: 'Wie lange noch bis Paris?', showGas: false },
      { speaker: 'Michel Gallimard', text: 'Noch etwa zwei Stunden. Wir können schneller fahren.', showGas: true },
      { speaker: 'Albert Camus', text: 'Das Wetter verschlechtert sich...', showGas: false },
      { speaker: 'Michel Gallimard', text: 'Ein bisschen Nebel macht nichts.', showGas: false },
      { speaker: 'Albert Camus', text: 'Die Bäume ziehen so schnell vorbei...', showGas: false },
      { speaker: 'Michel Gallimard', text: 'Der Motor läuft perfekt. Spürst du die Kraft?', showGas: false },
      { speaker: 'Albert Camus', text: 'Michel, vielleicht sollten wir langsamer...', showGas: true },
      { speaker: 'Michel Gallimard', text: 'Vertrau mir, ich habe alles unter Kontrolle.', showGas: false },
      { speaker: 'Albert Camus', text: 'Die Kurve da vorne... Michel!', showGas: false },
      { speaker: 'Michel Gallimard', text: 'Ich sehe sie, ich—', showGas: false }
    ];

    const playTypingSound = (speaker) => {
      if (!audioContextRef.current) {
        audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
      }
      
      const ctx = audioContextRef.current;
      const oscillator = ctx.createOscillator();
      const gainNode = ctx.createGain();
      
      const pitches = {
        'Michel Gallimard': 180,
        'Albert Camus': 160,
        'Janine Gallimard': 280,
        'Anne Gallimard': 320
      };
      
      oscillator.type = 'square';
      oscillator.frequency.value = pitches[speaker] || 200;
      gainNode.gain.value = 0.03;
      
      oscillator.connect(gainNode);
      gainNode.connect(ctx.destination);
      
      oscillator.start();
      gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.05);
      setTimeout(() => oscillator.stop(), 50);
    };

    useEffect(() => {
      if (gameState !== 'dialog' && gameState !== 'driving') return;
      
      const currentText = gameState === 'dialog' 
        ? dialogLines[dialogStep].text 
        : drivingDialogs[drivingDialogIndex]?.text || '';

      const currentSpeaker = gameState === 'dialog'
        ? dialogLines[dialogStep].speaker
        : drivingDialogs[drivingDialogIndex]?.speaker || '';

      setCurrentFullText(currentText);
      setDisplayedText('');
      setIsTyping(true);

      let currentIndex = 0;
      const typingSpeed = gameState === 'driving' ? 25 : 30;
      
      if (typingIntervalRef.current) {
        clearInterval(typingIntervalRef.current);
      }
      
      typingIntervalRef.current = setInterval(() => {
        if (currentIndex < currentText.length) {
          setDisplayedText(currentText.substring(0, currentIndex + 1));
          playTypingSound(currentSpeaker);
          currentIndex++;
        } else {
          setIsTyping(false);
          clearInterval(typingIntervalRef.current);
          typingIntervalRef.current = null;
        }
      }, typingSpeed);

      return () => {
        if (typingIntervalRef.current) {
          clearInterval(typingIntervalRef.current);
          typingIntervalRef.current = null;
        }
      };
    }, [dialogStep, drivingDialogIndex, gameState]);

    // Crash Animation useEffect
    useEffect(() => {
      if (!showCrashEffect) {
        if (crashAnimationRef.current) {
          cancelAnimationFrame(crashAnimationRef.current);
          crashAnimationRef.current = null;
        }
        if (crashMountRef.current) {
          while (crashMountRef.current.firstChild) {
            crashMountRef.current.removeChild(crashMountRef.current.firstChild);
          }
        }
        return;
      }
      
      if (!crashMountRef.current) return;

      while (crashMountRef.current.firstChild) {
        crashMountRef.current.removeChild(crashMountRef.current.firstChild);
      }

      const width = crashMountRef.current.clientWidth;
      const height = crashMountRef.current.clientHeight;

      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x2a3544, 5, 50);
      
      // Sky gradient
      const skyGeometry = new THREE.SphereGeometry(200, 32, 15);
      const skyMaterial = new THREE.ShaderMaterial({
        uniforms: {
          topColor: { value: new THREE.Color(0x88bbdd) },
          bottomColor: { value: new THREE.Color(0x5a6a7a) },
          offset: { value: 33 },
          exponent: { value: 0.6 }
        },
        vertexShader: `
          varying vec3 vWorldPosition;
          void main() {
            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
            vWorldPosition = worldPosition.xyz;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform vec3 topColor;
          uniform vec3 bottomColor;
          uniform float offset;
          uniform float exponent;
          varying vec3 vWorldPosition;
          void main() {
            float h = normalize(vWorldPosition + offset).y;
            gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
          }
        `,
        side: THREE.BackSide
      });
      const sky = new THREE.Mesh(skyGeometry, skyMaterial);
      scene.add(sky);

      // Sun
      const sunGeometry = new THREE.SphereGeometry(3, 32, 32);
      const sunMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xffffdd,
        fog: false
      });
      const sun = new THREE.Mesh(sunGeometry, sunMaterial);
      const angle = 20 * Math.PI / 180;
      const distance = 80;
      sun.position.set(
        distance * Math.cos(angle) * 0.3,
        distance * Math.sin(angle),
        -distance * Math.cos(angle)
      );
      scene.add(sun);

      const camera = new THREE.PerspectiveCamera(65, width / height, 0.1, 1000);
      camera.position.set(-15, 3, 5);
      camera.lookAt(0, 1, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(width, height);
      renderer.shadowMap.enabled = true;
      renderer.toneMappingExposure = 0.8;
      crashMountRef.current.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0x556677, 0.6);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffeedd, 0.4);
      directionalLight.position.set(5, 20, 5);
      scene.add(directionalLight);

      // Ground
      const groundGeometry = new THREE.PlaneGeometry(100, 100);
      const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x2d3a1f, roughness: 1 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      scene.add(ground);

      // Tree
      const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.6, 5, 8);
      const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x3d2817, roughness: 0.9 });
      const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
      trunk.position.set(0, 2.5, 0);
      scene.add(trunk);

      const foliageGeometry = new THREE.SphereGeometry(2.5, 8, 8);
      const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x1a4a1a, roughness: 1 });
      const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
      foliage.position.set(0, 6, 0);
      scene.add(foliage);

      // Car
      const carGroup = new THREE.Group();
      
      const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x0a0a0a, shininess: 100 });
      
      const body = new THREE.Mesh(new THREE.BoxGeometry(2.2, 1, 4.5), bodyMaterial);
      body.position.y = 0.5;
      carGroup.add(body);

      const roof = new THREE.Mesh(new THREE.BoxGeometry(1.7, 0.8, 2.8), bodyMaterial);
      roof.position.set(0, 1.35, 0.6);
      carGroup.add(roof);

      // Front (lighter)
      const frontMaterial = new THREE.MeshPhongMaterial({ color: 0x1a1a1a, shininess: 100 });
      const front = new THREE.Mesh(new THREE.BoxGeometry(2, 0.7, 1.8), frontMaterial);
      front.position.set(0, 0.8, -2.4);
      carGroup.add(front);

      // Rear (longer)
      const rear = new THREE.Mesh(new THREE.BoxGeometry(2, 0.7, 2.2), bodyMaterial);
      rear.position.set(0, 0.8, 2.6);
      carGroup.add(rear);

      // Dolphin fins
      const finMaterial = new THREE.MeshPhongMaterial({ color: 0x000000, shininess: 120 });
      
      const finLeft = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.6, 0.4), finMaterial);
      finLeft.position.set(-1.0, 1.1, 2.8);
      carGroup.add(finLeft);
      
      const finRight = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.6, 0.4), finMaterial);
      finRight.position.set(1.0, 1.1, 2.8);
      carGroup.add(finRight);

      // Bumpers
      const bumperMaterial = new THREE.MeshPhongMaterial({ color: 0x555555, shininess: 60 });
      
      const frontBumper = new THREE.Mesh(new THREE.BoxGeometry(2.3, 0.25, 0.3), bumperMaterial);
      frontBumper.position.set(0, 0.15, -3.3);
      carGroup.add(frontBumper);

      const rearBumper = new THREE.Mesh(new THREE.BoxGeometry(2.3, 0.25, 0.3), bumperMaterial);
      rearBumper.position.set(0, 0.15, 3.6);
      carGroup.add(rearBumper);

      const leftBumper = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 6.6), bumperMaterial);
      leftBumper.position.set(-1.1, 0.15, 0.15);
      carGroup.add(leftBumper);

      const rightBumper = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 6.6), bumperMaterial);
      rightBumper.position.set(1.1, 0.15, 0.15);
      carGroup.add(rightBumper);

      // Wheels
      const wheelGeometry = new THREE.CylinderGeometry(0.45, 0.45, 0.35, 16);
      const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x2b2b2b, shininess: 40 });
      
      const wheelFL = new THREE.Mesh(wheelGeometry, wheelMaterial);
      wheelFL.rotation.z = Math.PI / 2;
      wheelFL.position.set(-1.1, 0.45, 1.5);
      carGroup.add(wheelFL);

      const wheelFR = new THREE.Mesh(wheelGeometry, wheelMaterial);
      wheelFR.rotation.z = Math.PI / 2;
      wheelFR.position.set(1.1, 0.45, 1.5);
      carGroup.add(wheelFR);

      const wheelRL = new THREE.Mesh(wheelGeometry, wheelMaterial);
      wheelRL.rotation.z = Math.PI / 2;
      wheelRL.position.set(-1.1, 0.45, -1.5);
      carGroup.add(wheelRL);

      const wheelRR = new THREE.Mesh(wheelGeometry, wheelMaterial);
      wheelRR.rotation.z = Math.PI / 2;
      wheelRR.position.set(1.1, 0.45, -1.5);
      carGroup.add(wheelRR);

      // Detached wheel
      const detachedWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
      detachedWheel.rotation.z = Math.PI / 2;
      scene.add(detachedWheel);

      carGroup.position.set(-20, 0.45, 0);
      scene.add(carGroup);

      let time = 0;
      const animate = () => {
        time += 0.016;
        
        if (time < 1.5) {
          carGroup.position.x = -20 + time * 13;
        } else if (time < 2.0) {
          const impactProgress = (time - 1.5) / 0.5;
          // Stop before tree, not inside it
          carGroup.position.x = -0.5 + impactProgress * 0.3;
          carGroup.rotation.y = impactProgress * 0.3;
          carGroup.rotation.z = impactProgress * -0.2;
          
          front.scale.z = 1 - impactProgress * 0.5;
          front.position.z = -2.4 + impactProgress * 0.4; // Front crashes inward
          
          if (impactProgress > 0.3) {
            wheelFR.visible = false;
            detachedWheel.visible = true;
            const wheelProgress = (impactProgress - 0.3) / 0.7;
            detachedWheel.position.set(
              1.1 + wheelProgress * 5,
              0.45 - wheelProgress * 0.3,
              1.5 + wheelProgress * 2
            );
            detachedWheel.rotation.x = wheelProgress * 8;
            detachedWheel.rotation.y = wheelProgress * 3;
          }
        } else if (time < 4.0) {
          const rollProgress = (time - 2.0) / 2.0;
          detachedWheel.position.set(
            6.1 + rollProgress * 8,
            0.45,
            3.5 + rollProgress * 1
          );
          detachedWheel.rotation.x = 8 + rollProgress * 15;
          
          carGroup.rotation.y = 0.3 + Math.sin(time * 3) * 0.05;
          carGroup.rotation.z = -0.2 + Math.sin(time * 2) * 0.03;
        }

        renderer.render(scene, camera);
        crashAnimationRef.current = requestAnimationFrame(animate);
      };

      animate();

      return () => {
        if (crashAnimationRef.current) {
          cancelAnimationFrame(crashAnimationRef.current);
        }
        if (crashMountRef.current) {
          while (crashMountRef.current.firstChild) {
            crashMountRef.current.removeChild(crashMountRef.current.firstChild);
          }
        }
        renderer.dispose();
        scene.clear();
      };
    }, [showCrashEffect]);

    useEffect(() => {
      if (gameState === 'driving' && drivingDialogIndex < drivingDialogs.length) {
        setShowGasButton(drivingDialogs[drivingDialogIndex].showGas && speedLevel < 3);
      }
    }, [drivingDialogIndex, gameState, speedLevel]);

    useEffect(() => {
      // Always cleanup when not in driving state
      if (gameState !== 'driving') {
        if (animationRef.current) {
          cancelAnimationFrame(animationRef.current);
          animationRef.current = null;
        }
        if (sceneRef.current) {
          const { renderer, scene } = sceneRef.current;
          if (renderer) {
            renderer.dispose();
            if (renderer.domElement && renderer.domElement.parentNode) {
              renderer.domElement.parentNode.removeChild(renderer.domElement);
            }
          }
          if (scene) {
            scene.clear();
          }
          sceneRef.current = null;
        }
        // Clear mount ref completely
        if (mountRef.current) {
          while (mountRef.current.firstChild) {
            mountRef.current.removeChild(mountRef.current.firstChild);
          }
        }
        return;
      }
      
      if (!mountRef.current) return;

      // Clear any existing content
      while (mountRef.current.firstChild) {
        mountRef.current.removeChild(mountRef.current.firstChild);
      }

      const width = mountRef.current.clientWidth;
      const height = mountRef.current.clientHeight;

      if (width === 0 || height === 0) {
        console.error('Mount element has no dimensions');
        return;
      }

      // Initialize speedLevelRef
      speedLevelRef.current = speedLevel;

      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x2a3544, 15, 80);
      
      // Sky gradient with THREE.js
      const skyGeometry = new THREE.SphereGeometry(200, 32, 15);
      const skyMaterial = new THREE.ShaderMaterial({
        uniforms: {
          topColor: { value: new THREE.Color(0x88bbdd) },
          bottomColor: { value: new THREE.Color(0x5a6a7a) },
          offset: { value: 33 },
          exponent: { value: 0.6 }
        },
        vertexShader: `
          varying vec3 vWorldPosition;
          void main() {
            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
            vWorldPosition = worldPosition.xyz;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform vec3 topColor;
          uniform vec3 bottomColor;
          uniform float offset;
          uniform float exponent;
          varying vec3 vWorldPosition;
          void main() {
            float h = normalize(vWorldPosition + offset).y;
            gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
          }
        `,
        side: THREE.BackSide
      });
      const sky = new THREE.Mesh(skyGeometry, skyMaterial);
      scene.add(sky);

      // Sun
      const sunGeometry = new THREE.SphereGeometry(3, 32, 32);
      const sunMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xffffdd,
        fog: false
      });
      const sun = new THREE.Mesh(sunGeometry, sunMaterial);
      // 20 degrees above horizon
      const angle = 20 * Math.PI / 180;
      const distance = 80;
      sun.position.set(
        distance * Math.cos(angle) * 0.3,
        distance * Math.sin(angle),
        -distance * Math.cos(angle)
      );
      scene.add(sun);

      const camera = new THREE.PerspectiveCamera(65, width / height, 0.1, 1000);
      camera.position.set(0, 4.5, 12);
      camera.lookAt(0, 1, -10);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(width, height);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMappingExposure = 0.8;
      mountRef.current.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0x556677, 0.6);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffeedd, 0.4);
      directionalLight.position.set(5, 20, 5);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x4a3520, 0.4);
      scene.add(hemisphereLight);

      const carGroup = new THREE.Group();

      const bodyGeometry = new THREE.BoxGeometry(2.2, 1, 4.5);
      const bodyMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x0a0a0a, 
        shininess: 100,
        specular: 0x333333
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 0.5;
      body.castShadow = true;
      carGroup.add(body);

      const roofGeometry = new THREE.BoxGeometry(1.7, 0.8, 2.8);
      const roof = new THREE.Mesh(roofGeometry, bodyMaterial);
      roof.position.set(0, 1.35, 0.6); // Adjusted for longer rear
      roof.castShadow = true;
      carGroup.add(roof);

      // Front section (same color as body, flush with bottom)
      const frontGeometry = new THREE.BoxGeometry(2, 0.7, 1.8);
      const front = new THREE.Mesh(frontGeometry, bodyMaterial); // Same material as body
      front.position.set(0, 0.85, -2.4); // Adjusted height to be flush
      front.castShadow = true;
      carGroup.add(front);

      // Rear section (longer, flush with bottom)
      const rearGeometry = new THREE.BoxGeometry(2, 0.7, 2.2); // Longer: 2.2 instead of 1.8
      const rear = new THREE.Mesh(rearGeometry, bodyMaterial);
      rear.position.set(0, 0.85, 2.6); // Adjusted height to be flush, moved back
      rear.castShadow = true;
      carGroup.add(rear);

      // Dolphin fins at rear
      const finGeometry = new THREE.BoxGeometry(0.15, 0.6, 0.4);
      const finMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x000000, 
        shininess: 120
      });
      
      const finLeft = new THREE.Mesh(finGeometry, finMaterial);
      finLeft.position.set(-1.0, 1.1, 2.8); // Further back
      finLeft.castShadow = true;
      carGroup.add(finLeft);
      
      const finRight = new THREE.Mesh(finGeometry, finMaterial);
      finRight.position.set(1.0, 1.1, 2.8); // Further back
      finRight.castShadow = true;
      carGroup.add(finRight);

      // Bumpers (gray)
      const bumperMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x555555,
        shininess: 60
      });

      // Front bumper
      const frontBumper = new THREE.Mesh(new THREE.BoxGeometry(2.3, 0.25, 0.3), bumperMaterial);
      frontBumper.position.set(0, 0.15, -3.3);
      carGroup.add(frontBumper);

      // Rear bumper
      const rearBumper = new THREE.Mesh(new THREE.BoxGeometry(2.3, 0.25, 0.3), bumperMaterial);
      rearBumper.position.set(0, 0.15, 3.6);
      carGroup.add(rearBumper);

      // Side bumpers (left and right)
      const sideBumperGeometry = new THREE.BoxGeometry(0.25, 0.25, 6.6); // Length covers front to back
      const leftBumper = new THREE.Mesh(sideBumperGeometry, bumperMaterial);
      leftBumper.position.set(-1.1, 0.15, 0.15);
      carGroup.add(leftBumper);

      const rightBumper = new THREE.Mesh(sideBumperGeometry, bumperMaterial);
      rightBumper.position.set(1.1, 0.15, 0.15);
      carGroup.add(rightBumper);

      const grillGeometry = new THREE.BoxGeometry(1.8, 0.4, 0.2);
      const grillMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x888888,
        shininess: 120,
        specular: 0xffffff
      });
      const grill = new THREE.Mesh(grillGeometry, grillMaterial);
      grill.position.set(0, 0.4, -3.35);
      carGroup.add(grill);

      const headlightGeometry = new THREE.SphereGeometry(0.2, 8, 8);
      const headlightMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.8 });
      const headlightLeft = new THREE.Mesh(headlightGeometry, headlightMaterial);
      headlightLeft.position.set(-0.7, 0.5, -3.4);
      carGroup.add(headlightLeft);
      const headlightRight = new THREE.Mesh(headlightGeometry, headlightMaterial);
      headlightRight.position.set(0.7, 0.5, -3.4);
      carGroup.add(headlightRight);

      const taillightGeometry = new THREE.SphereGeometry(0.15, 8, 8);
      const taillightMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.8 });
      const taillightLeft = new THREE.Mesh(taillightGeometry, taillightMaterial);
      taillightLeft.position.set(-0.8, 0.6, 3.65);
      carGroup.add(taillightLeft);
      const taillightRight = new THREE.Mesh(taillightGeometry, taillightMaterial);
      taillightRight.position.set(0.8, 0.6, 3.65);
      carGroup.add(taillightRight);

      const windowMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x1a3344,
        transparent: true,
        opacity: 0.7,
        shininess: 90
      });
      const frontWindowGeometry = new THREE.BoxGeometry(1.6, 0.7, 0.1);
      const frontWindow = new THREE.Mesh(frontWindowGeometry, windowMaterial);
      frontWindow.position.set(0, 1.35, 0.95);
      carGroup.add(frontWindow);

      const wheelGeometry = new THREE.CylinderGeometry(0.45, 0.45, 0.35, 16);
      const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x2b2b2b, shininess: 40 });
      const tireMaterial = new THREE.MeshPhongMaterial({ color: 0x1a1a1a });

      const wheels = [];
      const wheelPositions = [
        [-1.1, 0, 1.5], [1.1, 0, 1.5],
        [-1.1, 0, -1.5], [1.1, 0, -1.5]
      ];

      wheelPositions.forEach(pos => {
        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
        wheel.rotation.z = Math.PI / 2;
        wheel.position.set(pos[0], pos[1], pos[2]);
        wheel.castShadow = true;

        const tireGeometry = new THREE.TorusGeometry(0.45, 0.15, 8, 16);
        const tire = new THREE.Mesh(tireGeometry, tireMaterial);
        tire.rotation.y = Math.PI / 2;
        tire.position.set(pos[0], pos[1], pos[2]);

        carGroup.add(wheel);
        carGroup.add(tire);
        wheels.push(wheel);
      });

      carGroup.position.y = 0.45;
      scene.add(carGroup);

      const roadGeometry = new THREE.PlaneGeometry(10, 300);
      const roadMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x2a2a2a,
        roughness: 0.9,
        metalness: 0.1
      });
      const road = new THREE.Mesh(roadGeometry, roadMaterial);
      road.rotation.x = -Math.PI / 2;
      road.position.z = -100;
      road.receiveShadow = true;
      scene.add(road);

      const grassMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x2d3a1f,
        roughness: 1,
        metalness: 0
      });
      
      const grassLeft = new THREE.Mesh(
        new THREE.PlaneGeometry(50, 300),
        grassMaterial
      );
      grassLeft.rotation.x = -Math.PI / 2;
      grassLeft.position.set(-30, -0.01, -100);
      grassLeft.receiveShadow = true;
      scene.add(grassLeft);

      const grassRight = new THREE.Mesh(
        new THREE.PlaneGeometry(50, 300),
        grassMaterial
      );
      grassRight.rotation.x = -Math.PI / 2;
      grassRight.position.set(30, -0.01, -100);
      grassRight.receiveShadow = true;
      scene.add(grassRight);

      const roadLines = [];
      for (let i = 0; i < 50; i++) {
        const lineGeometry = new THREE.PlaneGeometry(0.4, 3);
        const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xaaaa66 });
        const line = new THREE.Mesh(lineGeometry, lineMaterial);
        line.rotation.x = -Math.PI / 2;
        line.position.set(0, 0.02, -6 * i);
        scene.add(line);
        roadLines.push(line);
      }

      const trees = [];
      for (let i = 0; i < 50; i++) {
        const trunkGeometry = new THREE.CylinderGeometry(0.35, 0.45, 4, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x3d2817,
          roughness: 0.9
        });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);

        const foliageGeometry = new THREE.SphereGeometry(1.8, 8, 8);
        const foliageMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x1a4a1a,
          roughness: 1
        });
        const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
        foliage.position.y = 3;

        const tree = new THREE.Group();
        tree.add(trunk);
        tree.add(foliage);

        const side = (i % 2 === 0) ? 7 : -7;
        tree.position.set(side + (Math.random() - 0.5) * 3, 2, -10 * i);
        scene.add(tree);
        trees.push(tree);
      }

      sceneRef.current = {
        scene, camera, renderer, carGroup, wheels, trees, road, roadLines
      };

      let roadOffset = 0;
      let wheelRotation = 0;
      let sidewaysMotion = 0;
      let driftOffset = 0; // For smooth drift away from center
      let accelerationSmoothing = 0; // For smooth speed transitions

      const animate = () => {
        // Read current speed from ref - always up to date!
        const currentSpeed = speedLevelRef.current;
        
        // Smooth acceleration transition
        const targetSpeed = (currentSpeed + 1) * 0.18;
        accelerationSmoothing += (targetSpeed - accelerationSmoothing) * 0.05; // Smooth lerp
        const speed = accelerationSmoothing * (1 + Math.random() * 0.1);
        
        roadOffset += speed;
        wheelRotation += speed * 3;

        if (currentSpeed >= 2) {
          // Smooth drift away from center before wobbling
          if (driftOffset < 1.0) {
            driftOffset += 0.01; // Gradual drift
          }
          
          sidewaysMotion += 0.05;
          const wobble = Math.sin(sidewaysMotion);
          const driftAmount = Math.min(driftOffset, 1.0); // Cap at 1.0
          
          // Combine drift and wobble
          carGroup.position.x = driftAmount * 2 + wobble * 2.5 * driftAmount;
          carGroup.rotation.y = wobble * 0.2 * driftAmount;
          carGroup.rotation.z = Math.cos(sidewaysMotion) * 0.15 * driftAmount;
          
          camera.position.x = wobble * 0.4 * driftAmount;
          camera.rotation.z = wobble * 0.02 * driftAmount;
        } else {
          // Reset drift when slowing down (shouldn't happen in game, but good practice)
          driftOffset = 0;
          carGroup.position.x = Math.sin(roadOffset * 0.3) * 0.15 * currentSpeed;
          carGroup.rotation.y = 0;
          carGroup.rotation.z = Math.sin(roadOffset * 0.5) * 0.04 * (currentSpeed + 1);
          camera.position.x = 0;
          camera.rotation.z = 0;
        }

        carGroup.rotation.x = -speed * 0.15;

        wheels.forEach(wheel => {
          wheel.rotation.x = wheelRotation;
        });

        roadLines.forEach(line => {
          line.position.z += speed;
          if (line.position.z > 15) {
            line.position.z -= 300;
          }
        });

        trees.forEach(tree => {
          tree.position.z += speed;
          if (tree.position.z > 15) {
            tree.position.z -= 500;
          }
        });

        renderer.render(scene, camera);
        animationRef.current = requestAnimationFrame(animate);
      };

      animate();

      return () => {
        if (animationRef.current) {
          cancelAnimationFrame(animationRef.current);
        }
        if (sceneRef.current) {
          const { renderer, scene } = sceneRef.current;
          if (renderer) {
            if (renderer.domElement && renderer.domElement.parentNode) {
              renderer.domElement.parentNode.removeChild(renderer.domElement);
            }
            renderer.dispose();
          }
          if (scene) {
            scene.clear();
          }
        }
        if (mountRef.current) {
          while (mountRef.current.firstChild) {
            mountRef.current.removeChild(mountRef.current.firstChild);
          }
        }
      };
    }, [gameState]);

    const handleDialogNext = () => {
      if (isTyping) {
        // Complete the current text immediately
        if (typingIntervalRef.current) {
          clearInterval(typingIntervalRef.current);
          typingIntervalRef.current = null;
        }
        setDisplayedText(currentFullText);
        setIsTyping(false);
        return;
      }
      
      if (dialogStep < dialogLines.length - 1) {
        setDialogStep(dialogStep + 1);
      } else {
        setGameState('driving');
      }
    };

    const handleAccelerate = () => {
      if (speedLevel < 2) {
        const newSpeed = speedLevel + 1;
        setSpeedLevel(newSpeed);
        speedLevelRef.current = newSpeed;
        console.log('Speed increased to:', newSpeed, 'Ref:', speedLevelRef.current);
        setShowGasButton(false);
        if (drivingDialogIndex < drivingDialogs.length - 1) {
          setDrivingDialogIndex(drivingDialogIndex + 1);
        }
      } else {
        setShowCrashEffect(true);
        setCrashAnimationTime(0);
        setTimeout(() => {
          setGameState('crash');
          setShowCrashEffect(false);
        }, 4000);
      }
    };

    const handleDrivingDialogNext = () => {
      if (isTyping) {
        // Complete the current text immediately
        if (typingIntervalRef.current) {
          clearInterval(typingIntervalRef.current);
          typingIntervalRef.current = null;
        }
        setDisplayedText(currentFullText);
        setIsTyping(false);
        return;
      }
      
      if (drivingDialogIndex < drivingDialogs.length - 1) {
        setDrivingDialogIndex(drivingDialogIndex + 1);
      } else {
        setShowCrashEffect(true);
        setCrashAnimationTime(0);
        setTimeout(() => {
          setGameState('crash');
          setShowCrashEffect(false);
        }, 4000);
      }
    };

    const resetGame = () => {
      setGameState('intro');
      setDialogStep(0);
      setSpeedLevel(0);
      setDrivingDialogIndex(0);
      setShowGasButton(false);
      setDisplayedText('');
      setIsTyping(false);
    };

    const startGame = () => {
      setGameState('dialog');
    };

    const getCharacterAvatar = (name) => {
      const avatars = {
        'Michel Gallimard': { 
          image: 'images/cds/gallimard.jpeg'
        },
        'Albert Camus': { 
          image: 'images/cds/camus.jpeg'
        },
        'Janine Gallimard': { 
          image: 'images/cds/janine.jpeg'
        },
        'Anne Gallimard': { 
          image: 'images/cds/anne.jpeg'
        }
      };
      return avatars[name] || avatars['Michel Gallimard'];
    };

    if (gameState === 'intro') {
      return (
        <div className="min-h-screen bg-black relative overflow-hidden">
          <div className="absolute inset-0 bg-gradient-to-b from-gray-900 via-slate-800 to-black"></div>
          
          <div className="relative z-10 min-h-screen flex flex-col items-center justify-center p-8 fade-in-up">
            <div className="text-center mb-12">
              <h1 className="cinzel text-7xl font-bold text-gray-100 mb-4 tracking-wider drop-shadow-2xl">
                THE ABSURD JOURNEY
              </h1>
              <div className="h-1 w-64 mx-auto bg-gradient-to-r from-transparent via-gray-400 to-transparent mb-6"></div>
              <p className="garamond text-2xl text-gray-400 italic mb-8">
                Eine existenzielle Reise durch das Schicksal
              </p>
              <p className="garamond text-xl text-gray-500 mb-2">4. Januar 1960</p>
              <p className="garamond text-lg text-gray-600">Lourmarin, Provence</p>
            </div>

            <div className="max-w-2xl bg-black/70 backdrop-blur-sm border-2 border-gray-700 p-10 mb-8 vignette">
              <p className="garamond text-gray-300 text-xl leading-relaxed mb-6 italic">
                »Das Absurdeste ist, in einem Autounfall zu sterben.«
              </p>
              <p className="garamond text-gray-400 text-lg text-right">
                — Albert Camus, 1955
              </p>
            </div>

            <button
              onClick={startGame}
              className="cinzel bg-gradient-to-r from-gray-800 to-gray-900 hover:from-gray-700 hover:to-gray-800 text-gray-200 font-bold py-5 px-12 border-2 border-gray-600 transition-all duration-300 text-xl shadow-2xl hover:shadow-gray-700/50 hover:scale-105"
            >
              BEGINNEN
            </button>
          </div>
        </div>
      );
    }

    if (gameState === 'dialog') {
      const currentLine = dialogLines[dialogStep];
      const leftChar = 'Michel Gallimard';
      const rightChar = currentLine.otherSpeaker;
      const leftAvatar = getCharacterAvatar(leftChar);
      const rightAvatar = getCharacterAvatar(rightChar);

      return (
        <div className="min-h-screen bg-black relative overflow-hidden">
          <div className="absolute inset-0">
            <img 
              src="images/cds/lourmarin.jpeg" 
              alt="Lourmarin" 
              className="w-full h-full object-cover opacity-40"
            />
          </div>
          <div className="absolute inset-0 bg-black/40"></div>
          <div className="absolute inset-0 vignette"></div>

          <div className="relative z-10 min-h-screen flex flex-col items-center justify-center p-8">
            <div className="text-center mb-12 fade-in-up">
              <h1 className="cinzel text-5xl font-bold text-gray-200 mb-3 tracking-wide drop-shadow-xl">Lourmarin</h1>
              <p className="garamond text-gray-400 text-2xl italic">4. Januar 1960</p>
            </div>

            <div className="flex gap-20 mb-12">
              <div className={`transition-all duration-700 relative ${currentLine.speaker === leftChar ? 'scale-110 brightness-110' : 'opacity-50 scale-95'}`}>
                <div className="w-48 h-72 bg-gradient-to-b from-gray-700 via-gray-800 to-gray-900 shadow-2xl relative overflow-hidden">
                  <img src={leftAvatar.image} alt={leftChar} className="w-full h-full object-cover" />
                  <div className="absolute bottom-0 left-0 right-0 bg-black/90 py-2 px-3">
                    <div className="cinzel text-gray-100 font-semibold text-base text-center">{leftChar}</div>
                  </div>
                </div>
              </div>

              <div className={`transition-all duration-700 relative ${currentLine.speaker === rightChar ? 'scale-110 brightness-110' : 'opacity-50 scale-95'}`}>
                <div className="w-48 h-72 bg-gradient-to-b from-gray-700 via-gray-800 to-gray-900 shadow-2xl relative overflow-hidden">
                  <img src={rightAvatar.image} alt={rightChar} className="w-full h-full object-cover" />
                  <div className="absolute bottom-0 left-0 right-0 bg-black/90 py-2 px-3">
                    <div className="cinzel text-gray-100 font-semibold text-base text-center">{rightChar}</div>
                  </div>
                </div>
              </div>
            </div>

            <div className="max-w-4xl w-full bg-black/80 backdrop-blur-sm border-2 border-gray-700 shadow-2xl p-8 vignette">
              <div className="cinzel font-bold text-3xl mb-5 text-gray-100 tracking-wide">
                {currentLine.speaker}:
              </div>
              <div className="garamond text-gray-100 text-2xl mb-6 leading-relaxed" style={{ minHeight: '80px' }}>
                {displayedText}
                {isTyping && <span className="animate-pulse text-gray-100">│</span>}
              </div>
              <button
                onClick={handleDialogNext}
                className={`cinzel w-full bg-gradient-to-r from-gray-800 to-gray-900 hover:from-gray-700 hover:to-gray-800 text-gray-200 font-bold py-4 px-8 border-2 border-gray-600 transition-all duration-300 text-xl shadow-xl hover:scale-[1.02]`}
              >
                {dialogStep < dialogLines.length - 1 ? 'Weiter' : 'LOSFAHREN'}
              </button>
            </div>
          </div>
        </div>
      );
    }

    if (gameState === 'driving') {
      const currentDialog = drivingDialogs[drivingDialogIndex];
      const leftChar = 'Michel Gallimard';
      const rightChar = 'Albert Camus';
      const leftAvatar = getCharacterAvatar(leftChar);
      const rightAvatar = getCharacterAvatar(rightChar);

      return (
        <div className="h-screen bg-gray-900 relative flex flex-col overflow-hidden">
          <div ref={mountRef} className="w-full" style={{ height: 'calc(100vh - 240px)', visibility: showCrashEffect ? 'hidden' : 'visible' }}></div>
          
          {showCrashEffect && (
            <div className="absolute inset-0 z-50 bg-black">
              <div ref={crashMountRef} className="w-full h-full"></div>
            </div>
          )}

          <div className="w-full bg-gradient-to-t from-black via-gray-900 to-transparent relative p-4 flex items-center justify-center vignette" style={{ height: '240px', flexShrink: 0, opacity: showCrashEffect ? 0 : 1, transition: 'opacity 0.3s' }}>
            <div className="max-w-6xl w-full flex gap-4 items-end">
              <div className={`transition-all duration-500 relative ${currentDialog.speaker === leftChar ? 'scale-105 brightness-110' : 'opacity-60 scale-95'}`}>
                <div className="w-32 h-48 bg-gradient-to-b from-gray-700 via-gray-800 to-gray-900 shadow-2xl relative overflow-hidden">
                  <img src={leftAvatar.image} alt={leftChar} className="w-full h-full object-cover" />
                  <div className="absolute bottom-0 left-0 right-0 bg-black/90 py-1 px-2">
                    <div className="cinzel text-gray-100 font-semibold text-xs text-center">{leftChar}</div>
                  </div>
                </div>
              </div>

              <div className="flex-1 bg-black/90 backdrop-blur-sm border-2 border-gray-700 shadow-2xl p-4">
                <div className="cinzel font-bold text-xl mb-2 text-gray-100">
                  {currentDialog.speaker}:
                </div>
                <div className="garamond text-gray-100 text-lg mb-3 leading-relaxed" style={{ minHeight: '50px' }}>
                  {displayedText}
                  {isTyping && <span className="animate-pulse text-gray-100">│</span>}
                </div>

                <div>
                  {showGasButton ? (
                    <button
                      onClick={handleAccelerate}
                      className="cinzel w-full bg-gradient-to-r from-red-900 to-red-950 hover:from-red-800 hover:to-red-900 text-red-100 font-bold py-2 px-4 border-2 border-red-700 transition-all duration-300 shadow-lg shadow-red-900/50 hover:shadow-red-800/70 hover:scale-[1.01] text-base"
                      style={{ animation: 'flicker 2s infinite' }}
                    >
                      MEHR GAS GEBEN
                    </button>
                  ) : (
                    <button
                      onClick={handleDrivingDialogNext}
                      className={`cinzel w-full bg-gradient-to-r from-gray-800 to-gray-900 hover:from-gray-700 hover:to-gray-800 text-gray-200 font-bold py-2 px-4 border-2 border-gray-600 transition-all duration-300 text-base hover:scale-[1.01]`}
                    >
                      ▶ Weiter
                    </button>
                  )}
                </div>
              </div>

              <div className={`transition-all duration-500 relative ${currentDialog.speaker === rightChar ? 'scale-105 brightness-110' : 'opacity-60 scale-95'}`}>
                <div className="w-32 h-48 bg-gradient-to-b from-gray-700 via-gray-800 to-gray-900 shadow-2xl relative overflow-hidden">
                  <img src={rightAvatar.image} alt={rightChar} className="w-full h-full object-cover" />
                  <div className="absolute bottom-0 left-0 right-0 bg-black/90 py-1 px-2">
                    <div className="cinzel text-gray-100 font-semibold text-xs text-center">{rightChar}</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    }

    if (gameState === 'crash') {
      return (
        <div className="min-h-screen bg-black flex items-center justify-center p-8 relative overflow-hidden">
          <div className="absolute inset-0">
            <img 
              src="images/cds/pines.jpeg" 
              alt="Pines" 
              className="w-full h-full object-cover opacity-30"
            />
          </div>
          <div className="absolute inset-0 bg-gradient-to-b from-black/60 via-black/40 to-black/80"></div>
          <div className="absolute inset-0 vignette"></div>

          <div className="max-w-4xl w-full text-center relative z-10 fade-in-up">
            <div className="mb-12">
              <h1 className="cinzel text-7xl font-bold text-gray-300 mb-8 drop-shadow-2xl tracking-wider">
                GAME OVER
              </h1>
              <div className="h-1 w-96 mx-auto bg-gradient-to-r from-transparent via-gray-500 to-transparent mb-12"></div>
            </div>

            <div className="bg-black/80 backdrop-blur-sm border-2 border-gray-700 p-12 mb-12 vignette">
              <p className="garamond text-gray-200 text-3xl mb-8 leading-relaxed italic">
                »Das Absurdeste ist, in einem Autounfall zu sterben.«
              </p>
              <div className="h-px w-64 mx-auto bg-gradient-to-r from-transparent via-gray-600 to-transparent my-8"></div>
              <p className="cinzel text-gray-300 text-2xl mb-6 tracking-wide">
                ALBERT CAMUS
              </p>
              <p className="garamond text-gray-400 text-xl mb-4">
                1913 – 1960
              </p>
              <div className="h-px w-48 mx-auto bg-gradient-to-r from-transparent via-gray-700 to-transparent my-6"></div>
              <p className="garamond text-gray-500 text-lg mb-2">
                Villeblevin, Frankreich
              </p>
              <p className="garamond text-gray-600 text-lg">
                4. Januar 1960
              </p>
            </div>

            <div className="space-y-4">
              <button
                onClick={resetGame}
                className="cinzel w-full max-w-md mx-auto block bg-gradient-to-r from-gray-800 to-gray-900 hover:from-gray-700 hover:to-gray-800 text-gray-200 font-bold py-6 px-12 border-2 border-gray-600 transition-all duration-300 text-2xl shadow-2xl hover:shadow-gray-700/50 hover:scale-105"
              >
                Noch einmal spielen
              </button>
              <p className="garamond text-gray-600 text-sm italic">
                Das Schicksal lässt sich nicht ändern, nur wiederholen
              </p>
            </div>
          </div>
        </div>
      );
    }
  };

  ReactDOM.createRoot(document.getElementById('root')).render(<CamusGame />);
  </script>
</body>
</html>